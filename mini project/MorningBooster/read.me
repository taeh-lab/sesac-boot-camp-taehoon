# 🐻 MorningBooster
> **반복 작업을 한 번의 클릭으로 정리하는 로컬 자동화 유틸리티**

## 1. 프로젝트 개요
**MorningBooster**는 매일 반복되는 “작업 시작 준비 과정”을 최소 단위로 자동화하기 위해 제작된 **경량 로컬 데스크톱 유틸리티**입니다. 이 프로젝트의 목표는 단순한 기능 확장이 아니라, **반복 행동에서 발생하는 인지적 피로를 제거**하는 것이었습니다.

## 2. 문제 정의 (Problem)
기존의 작업 시작 방식에서 다음과 같은 비효율을 발견했습니다.
* **반복의 피로:** 매일 동일한 웹 서비스와 로컬 앱을 수동으로 실행.
* **리소스 낭비:** 작업 시작 전 불필요한 클릭과 대기 시간 발생.
* **파편화된 환경:** 브라우저, 앱, 링크 등 사용자마다 다른 환경으로 인한 자동화의 어려움.
* **과잉 설계:** 서버, 계정, 동기화가 필요한 기존 솔루션들은 문제의 크기 대비 과도한 복잡도를 가짐.

## 3. 해결 전략 (Solution)

### 3.1 최소 구조 선택
* **Zero Infrastructure:** 서버 ❌, 계정 ❌, 네트워크 권한 ❌
* **Stand-alone:** 로컬 실행 중심의 단일 `.exe` 구조 채택으로 즉시성 확보.

### 3.2 사용자 환경 대응
* **Config Separation:** 설정 정보를 `JSON` 파일로 외부 분리하여 코드 수정 없이 커스터마이징 가능.
* **Environment Agnostic:** 브라우저 경로 및 윈도우 환경 차이를 설정 레벨에서 유연하게 흡수.

### 3.3 MVP(Minimum Viable Product) 중심 설계
* **Lightweight:** Python 표준 라이브러리만을 활용한 초경량 설계.
* **Efficiency:** 핵심 로직을 30~40줄 내외로 최적화하여 유지보수성 극대화.
* **Deployment First:** “지금 당장 배포하고 쓸 수 있는 상태”를 목표로 제작.

## 4. UX 설계 포인트

### 4.1 심리적 대기 시간 제거
* **Non-blocking UI:** `Threading`을 활용해 브라우저 실행 중에도 UI 멈춤(Freezing) 현상 제거.
* **Feedback:** 사용자가 “작동 여부”를 고민하지 않도록 실시간 상태 업데이트 제공.

### 4.2 비기술 사용자 고려
* **Visual Status:** 딱딱한 텍스트 로그 대신 캐릭터를 활용한 시각적 상태 표현.
* **Emotional UX:** 곰돌이 캐릭터를 활용해 툴에 대한 심리적 장벽을 낮추고 친화적 피드백 제공.

## 5. 배포 및 사용성
* **Portable:** `PyInstaller` 기반 단일 파일 배포로 별도의 설치 과정 제거.
* **Zero Setup:** 권한 요청이나 계정 생성 없이 실행 즉시 기능 수행.
* **User Validated:** 실제 비개발자 사용자에게 배포하여 즉시 사용성 및 반복 실행 사례 검증 완료.

## 6. 확장 가능성 및 비즈니스 관점
본 프로젝트는 무분별한 기능 확장 대신 **사용자의 행동 흐름에 집중**합니다.
* **Viral Loop:** 사용 습관에 자연스럽게 녹아드는 실행 흐름 설계.
* **Traffic Bridge:** 실행 시 특정 페이지(티스토리) 연동을 통한 플랫폼 유입 유도.
* **Value Capture:** 별도 마케팅 비용 없이 발생하는 반복 트래픽 구조 구축.
* 유틸리티 자체의 기능을 넘어, **사용자의 루틴에 결합되는 가치**를 목표로 설계되었습니다.

## 7. 정리
> **MorningBooster는 “더 많은 기능”이 아니라, “덜 생각해도 되는 아침”을 만드는 도구입니다.**

---

# 🚀 Technical Architecture & Engineering

## 1. System Architecture
본 프로그램은 관심사의 분리(SoC) 원칙에 따라 설계되었습니다.

```text
 [UI Layer]             [Logic Layer]            [Data Layer]
┌──────────────┐       ┌──────────────┐        ┌───────────────┐
│   main.py    ├──────>│   engine.py  │ <────> │   storage.py  │
│ (Tkinter UI) │       │ (Exec Logic) │        │ (JSON Config) │
└──────┬───────┘       └──────────────┘        └───────────────┘
       │
       ▼
┌──────────────┐
│  loading.py  │
│(Async/Thread)│
└──────────────┘

main.py: UI 제어 및 사용자 인터페이스 관리

engine.py: 브라우저 및 외부 프로세스 실행 핵심 로직

storage.py: JSON 기반 설정 파일 영속성 관리

loading.py: 멀티스레딩 기반 Non-blocking UX 구현

3. 주요 기술 선택 이유 (The "Why")
Q. 왜 GUI 라이브러리로 Tkinter를 선택했는가?
A. "별도의 외부 라이브러리 설치 없이 Python 표준 라이브러리만으로 즉시 구동 가능하기 때문입니다. 
프로젝트의 핵심 가치인 '경량화'와 '빠른 프로토타이핑'에 가장 적합하며, 
배포 시 용량을 최소화할 수 있는 최적의 선택지였습니다."

Q. 왜 별도의 스레드(threading)를 사용했는가?
A. "여러 프로그램을 실행하는 작업은 수 초 이상의 시간이 소요됩니다. 
이를 메인 스레드에서 처리할 경우 GUI가 응답 없음(Not Responding) 상태가 되어 UX를 해칩니다. 
따라서 Worker Thread를 분리하여 실행 로직을 처리하고, 
메인 스레드에서는 로딩 애니메이션을 유지함으로써 높은 반응성을 확보했습니다."

Q. 왜 설정을 JSON 포맷으로 홈 디렉터리에 저장하는가?
A. "프로그램의 위치와 관계없이 설정을 영속적으로 유지하기 위함입니다.
사용자의 홈 디렉터리는 운영체제별로 보장된 안전한 공간이며, 
JSON은 텍스트 기반이라 가독성이 좋아 향후 디버깅 및 사용자 직접 수정이 용이합니다."

Q. 왜 UI와 로직을 분리(main.py & engine.py)했는가?
A. "관심사의 분리(Separation of Concerns) 원칙을 준수하기 위해서입니다. 
UI 디자인 변경이 실행 로직에 영향을 주지 않도록 설계하여 
코드의 결합도(Coupling)를 낮추고 유지보수 효율을 극대화했습니다."

4. 핵심 코드 분석 (The "How")
📂 리소스 경로 최적화 (storage.py)
.exe 패키징 환경과 개발 환경 모두에서 이미지/데이터 파일을 정확히 참조하기 위한 로직입니다.

Python

def get_resource_path(relative_path):
    """ PyInstaller 패키징 대응 리소스 경로 반환 """
    try:
        # PyInstaller 실행 시 생성되는 임시 폴더 경로 참조
        base_path = sys._MEIPASS
    except Exception:
        # 일반 파이썬 실행 환경
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)
📂 동적 위젯 생성 및 데이터 동기화 (main.py)
사용자의 설정 데이터에 따라 UI 요소가 실시간으로 변하는 유연한 인터페이스 구현 방식입니다.

Python

# SettingsWindow 클래스 내부 로직 예시
for i, window_group in enumerate(self.config.get("windows", [])):
    # 각 데이터 항목에 대응하는 프레임 및 버튼 동적 생성
    ttk.Button(title_row_frame, 
               text="X 창 삭제", 
               command=lambda idx=i: self._delete_window(idx)).pack()
분석: 설정 데이터(self.config)를 순회하며 위젯을 생성하고, 
Lambda 식을 활용해 각 버튼에 고유한 인덱스를 바인딩하여 
데이터 삭제 및 UI 갱신이 유기적으로 이루어지도록 설계했습니다.

## 💻 개발 및 빌드 과정 (Development & Build)

MorningBooster 프로젝트의 개발 환경 구축부터 실행 파일(.exe) 배포까지의 과정입니다.

### 1. 개발 환경 확인 및 라이브러리 설치
프로젝트에 필요한 파이썬 환경을 점검하고 의존성 라이브러리를 설치합니다.

* `python --version`: 파이썬 버전 확인 및 호환성 점검
* `pip list`: 설치된 라이브러리 목록 및 버전 충돌 확인
* `pip install Pillow`: GUI 이미지(로딩 화면 등) 처리 라이브러리 설치
* `pip install pyinstaller`: 실행 파일(.exe) 변환 도구 설치

### 2. 코드 개발 및 테스트 실행
빌드 전 스크립트 상태에서 기능을 최종 테스트합니다.

```bash
# 프로젝트 디렉토리로 이동
cd "mini project\MorningBooster"

# 애플리케이션 직접 실행 테스트
python main.py

3. 실행 파일(.exe) 빌드
사용자 배포를 위해 PyInstaller를 사용하여 패키징을 진행합니다.

기본 빌드
pyinstaller main.py: 기본적인 빌드 방식 (여러 파일로 생성)

--onefile: 모든 파일을 하나의 .exe로 통합

--windowed: 실행 시 콘솔(터미널) 창 숨김

--name MorningBooster: 실행 파일 이름 지정

--icon="1-f1c387e3.ico": 프로그램 아이콘 적용

