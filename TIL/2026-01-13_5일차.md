# 📅 2026-01-13 학습 기록

## 📊 오늘의 학습 요약

| 항목 | 내용 |
| :--- | :--- |
| **학습 주제** | FastAPI 계층형 아키텍처 리팩토링 및 SQLAlchemy ORM 도입 |
| **목표 달성도** | ⭐⭐⭐⭐⭐ (5/5) |
| **핵심 키워드** | #Refactoring #Layered_Architecture #ORM #SQLAlchemy #DI |

---

## 💡 주요 학습 내용

### 1️⃣ 기술적 핵심 (Technical Points)
오늘 실습에서는 단일 파일(`main.py`) 구조의 프로젝트를 전문적인 **계층형 아키텍처**로 전환하고, **SQLAlchemy ORM**을 도입하여 코드를 현대화했습니다.

* **계층형 아키텍처(Layered Architecture) 설계**
    * 단일 파일에 몰려있던 코드를 역할에 따라 6개의 계층으로 분리하여 구조화했습니다.
    * `api`: 클라이언트의 요청을 받는 경로(Route) 정의
    * `service`: 실제 비즈니스 로직 및 트랜잭션 처리
    * `repository`: 데이터베이스 직접 접근 및 데이터 조작 (DAO)
    * `schemas`: Pydantic을 이용한 데이터 검증 및 응답 규격 정의
    * `models`: 데이터베이스 테이블과 매핑되는 파이썬 객체 정의
    * `core`: DB 연결 설정 및 환경 변수(`env`) 등 핵심 설정 관리

* **ORM(SQLAlchemy) 전환**
    * `repository` 계층에서 직접 작성하던 복잡한 SQL 문자열(`INSERT INTO ...`)을 모두 제거했습니다.
    * 파이썬 객체로 데이터베이스를 조작하는 **SQLAlchemy ORM** 방식으로 코드를 완전히 교체했습니다.

* **의존성 주입(Dependency Injection)**
    * FastAPI의 `Depends`를 사용하여, 각 API 요청마다 독립적이고 안전한 데이터베이스 세션(Session)을 사용하도록 `get_db` 의존성을 주입했습니다.

### 2️⃣ 논의 및 회고 (Discussion & Reflection)
* **핵심 깨달음**: "ORM은 SQL을 직접 작성하지 않게 함으로써 개발자가 비즈니스 로직에 더 집중할 수 있게 해주고, 데이터베이스와의 결합도를 낮춰 유지보수성을 극대화한다."
* **느낀 점**: 리팩토링 과정에서 발생하는 오류는 구조가 견고해지는 과정이며, 점진적으로 수정하고 단계별로 테스트하는 것이 가장 빠르고 안정적인 방법임을 체감했습니다.

---

## 🚀 내일의 계획
- [ ] **Alembic**을 사용한 데이터베이스 마이그레이션 설정 학습
- [ ] 오늘 구축한 각 계층에 대한 **단위 테스트(Unit Test)** 코드 작성
- [ ] **API 문서 커스터마이징** (태그 설정 및 설명 추가)